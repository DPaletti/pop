# Inspired by: https://github.com/thomashirtz/noisy-networks/blob/main/noisynetworks.py
import torch.nn as nn
import torch.nn.functional as F
import torch as th
from ray.rllib.models.torch.modules.noisy_layer import NoisyLayer


class NoisyLayer(nn.Module):
    def __init__(
        self,
        input_features: int,
        output_features: int,
        sigma: float,
        training: bool,
    ):
        super(NoisyLayer, self).__init__()

        self.sigma = sigma
        self.input_features = input_features
        self.output_features = output_features
        self.training = training

        self.mu_bias = nn.Parameter(th.FloatTensor(output_features))
        self.sigma_bias = nn.Parameter(th.FloatTensor(output_features))
        self.mu_weight = nn.Parameter(th.FloatTensor(output_features, input_features))
        self.sigma_weight = nn.Parameter(
            th.FloatTensor(output_features, input_features)
        )

        self.register_buffer("epsilon_input", th.FloatTensor(input_features))
        self.register_buffer("epsilon_output", th.FloatTensor(output_features))

        self.bound = input_features ** (-0.5)

        self.parameter_initialization()
        self.sample_noise()

    def forward(self, x: th.Tensor, sample_noise: bool = True) -> th.Tensor:
        if not self.training:
            return F.linear(x, weight=self.mu_weight, bias=self.mu_bias)

        if sample_noise:
            self.sample_noise()

        return nn.functional.linear(x, weight=self.weight, bias=self.bias)

    @property
    def weight(self) -> th.Tensor:
        return (
            self.sigma_weight * th.ger(self.epsilon_output, self.epsilon_input)
            + self.mu_weight
        )

    @property
    def bias(self) -> th.Tensor:
        return self.sigma_bias * self.epsilon_output + self.mu_bias

    def sample_noise(self) -> None:
        # epsilon_input and epsilon_output are registered buffers of this module
        self.epsilon_input = self.get_noise_tensor(self.input_features)
        self.epsilon_output = self.get_noise_tensor(self.output_features)

    def parameter_initialization(self) -> None:
        self.mu_bias.data.uniform_(-self.bound, self.bound)
        self.sigma_bias.data.fill_(self.sigma * self.bound)
        self.mu_weight.data.uniform_(-self.bound, self.bound)
        self.sigma_weight.data.fill_(self.sigma * self.bound)

    def get_noise_tensor(self, features: int) -> th.Tensor:
        noise = (
            th.FloatTensor(features)
            .uniform_(-self.bound, self.bound)
            .to(self.mu_bias.device)
        )
        return th.sign(noise) * th.sqrt(th.abs(noise))
